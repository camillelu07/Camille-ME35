import network
import time
from umqtt.simple import MQTTClient
import ssl
import secrets
import neopixel
import json
from machine import Pin

class MQTTController:
    def __init__(self):
        self.SSID = secrets.SSID
        self.PASSWORD = secrets.PWD
        
        # Neopixel initialize
        self.np = neopixel.NeoPixel(Pin(15), 2)
        self.entered_time_35 = 0
        self.entered_time_34 = 0
        
        # MQTT settings
        self.MQTT_BROKER = secrets.mqtt_url 
        self.MQTT_PORT = 8883
        self.MQTT_USERNAME = secrets.mqtt_username 
        self.MQTT_PASSWORD = secrets.mqtt_password 
        self.CLIENT_ID = "controller"
        self.TOPIC_PUB = "/ME35/control"
        
        # Control buttons
        self.button_35 = Pin(35, Pin.IN, Pin.PULL_UP)
        self.button_34 = Pin(34, Pin.IN, Pin.PULL_UP)
        
        # Track button states for detecting both pressed
        self.button_35_pressed = False
        self.button_34_pressed = False
        
        # Double press detection for D35
        self.last_press_time_35 = 0
        self.double_press_window = 400  # milliseconds for double press detection
        self.press_count_35 = 0
        
        # Double press detection for D34
        self.last_press_time_34 = 0
        self.press_count_34 = 0
        
        self.client = None  # Initialize client variable
        
        # Set up interrupts
        self.button_35.irq(trigger=Pin.IRQ_FALLING | Pin.IRQ_RISING, handler=self.button_35_handler)
        self.button_34.irq(trigger=Pin.IRQ_FALLING | Pin.IRQ_RISING, handler=self.button_34_handler)
        
        print("Controller initialized")
    
    def debounce_check_35(self):
        now_time = time.ticks_ms()
        if time.ticks_diff(now_time, self.entered_time_35) < 50:  # Shorter debounce for double press
            return False
        self.entered_time_35 = now_time
        return True
    
    def debounce_check_34(self):
        now_time = time.ticks_ms()
        if time.ticks_diff(now_time, self.entered_time_34) < 50:  # Shorter debounce for double press
            return False
        self.entered_time_34 = now_time
        return True
    
    def handle_35_single_or_double(self):
        """Handle single or double press for D35"""
        now_time = time.ticks_ms()
        
        # Check if this is within the double press window
        if time.ticks_diff(now_time, self.last_press_time_35) < self.double_press_window:
            # This is a double press
            self.press_count_35 = 2
            print("Double press detected on D35")
            if self.client:
                command = {"action": "motors_opposite_reverse"}
                msg = json.dumps(command)
                self.client.publish(self.TOPIC_PUB, msg)
                print(f"Published: {msg}")
                self.np[0] = (255, 128, 0)  # Orange for double press (reverse direction)
                self.np.write()
                print("D35 double pressed - Motors opposite direction (reversed) command sent")
            else:
                print("ERROR: MQTT client not connected!")
        else:
            # This is a single press, but wait to see if another press comes
            self.press_count_35 = 1
            self.last_press_time_35 = now_time
            print("Single press pending on D35...")
    
    def handle_34_single_or_double(self):
        """Handle single or double press for D34"""
        now_time = time.ticks_ms()
        
        # Check if this is within the double press window
        if time.ticks_diff(now_time, self.last_press_time_34) < self.double_press_window:
            # This is a double press - activate ultrasonic sensor
            self.press_count_34 = 2
            print("Double press detected on D34")
            if self.client:
                command = {"action": "activate_sensor"}
                msg = json.dumps(command)
                self.client.publish(self.TOPIC_PUB, msg)
                print(f"Published: {msg}")
                self.np[0] = (255, 255, 0)  # Yellow for sensor activation
                self.np.write()
                print("D34 double pressed - Ultrasonic sensor activation command sent")
            else:
                print("ERROR: MQTT client not connected!")
        else:
            # This is a single press, but wait to see if another press comes
            self.press_count_34 = 1
            self.last_press_time_34 = now_time
            print("Single press pending on D34...")
    
    def button_35_handler(self, p):
        if not self.debounce_check_35():
            return
        
        # Check if button is pressed (LOW when pressed due to PULL_UP)
        if self.button_35.value() == 0:
            print("Button D35 pressed")
            self.button_35_pressed = True
            self.handle_35_single_or_double()
        else:
            print("Button D35 released")
            self.button_35_pressed = False
    
    def button_34_handler(self, p):
        if not self.debounce_check_34():
            return
        
        # Check if button is pressed (LOW when pressed due to PULL_UP)
        if self.button_34.value() == 0:
            print("Button D34 pressed")
            self.button_34_pressed = True
            self.handle_34_single_or_double()
        else:
            print("Button D34 released")
            self.button_34_pressed = False
    
    def check_single_press_timeout(self):
        """Check if single press timeout has elapsed and send single press command"""
        # Check D35 single press timeout
        if self.press_count_35 == 1:
            now_time = time.ticks_ms()
            if time.ticks_diff(now_time, self.last_press_time_35) >= self.double_press_window:
                # Single press confirmed
                print("Single press confirmed on D35")
                if self.client:
                    command = {"action": "motors_opposite"}
                    msg = json.dumps(command)
                    self.client.publish(self.TOPIC_PUB, msg)
                    print(f"Published: {msg}")
                    self.np[0] = (255, 0, 255)  # Magenta for single press
                    self.np.write()
                    print("D35 single pressed - Motors opposite direction command sent")
                else:
                    print("ERROR: MQTT client not connected!")
                self.press_count_35 = 0  # Reset
        
        # Check D34 single press timeout
        if self.press_count_34 == 1:
            now_time = time.ticks_ms()
            if time.ticks_diff(now_time, self.last_press_time_34) >= self.double_press_window:
                # Single press confirmed
                print("Single press confirmed on D34")
                if self.client:
                    command = {"action": "servo_rotate"}
                    msg = json.dumps(command)
                    self.client.publish(self.TOPIC_PUB, msg)
                    print(f"Published: {msg}")
                    self.np[0] = (0, 255, 255)  # Cyan for servo
                    self.np.write()
                    print("D34 single pressed - Servo rotate command sent")
                else:
                    print("ERROR: MQTT client not connected!")
                self.press_count_34 = 0  # Reset
    
    def connect_wifi(self):
        self.wlan = network.WLAN(network.STA_IF)
        self.wlan.active(True)
        if not self.wlan.isconnected():
            print("Connecting to WiFi...")
            self.wlan.connect(self.SSID, self.PASSWORD)
            timeout = 10
            while not self.wlan.isconnected() and timeout > 0:
                time.sleep(1)
                timeout -= 1
        
        if self.wlan.isconnected():
            print("WiFi Connected! IP:", self.wlan.ifconfig()[0])
            return True
        else:
            print("WiFi connection failed!")
            return False
    
    def mqtt_connect(self):
        try:
            self.client = MQTTClient(
                client_id=self.CLIENT_ID,
                server=self.MQTT_BROKER,
                port=self.MQTT_PORT,
                user=self.MQTT_USERNAME,
                password=self.MQTT_PASSWORD,
                ssl=True,
                ssl_params={'server_hostname': self.MQTT_BROKER}
            )
            self.client.connect()
            print("MQTT Connected successfully!")
            print(f"Publishing to topic: {self.TOPIC_PUB}")
            return True
        except OSError as e:
            print(f"MQTT Connection failed: {e}")
            return False
        except Exception as e:
            print(f"Unexpected error: {e}")
            return False

# Main execution
controller = MQTTController()
if controller.connect_wifi():
    if controller.mqtt_connect():
        print("Controller ready - waiting for button presses...")
        
        while True:
            controller.check_single_press_timeout()  # Check for single press timeout
            time.sleep(0.05)  # Check frequently for responsive timing
    else:
        print("MQTT connection failed - controller not functional")
else:
    print("WiFi connection failed!")
